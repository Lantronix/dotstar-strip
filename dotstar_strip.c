
/*****************************************************************************/
/*                              Legal                                        */
/*****************************************************************************/

/*
** Copyright �2015. Lantronix, Inc. All Rights Reserved.
** By using this software, you are agreeing to the terms of the Software
** Development Kit (SDK) License Agreement included in the distribution package
** for this software (the �License Agreement�).
** Under the License Agreement, this software may be used solely to create
** custom applications for use on the Lantronix xPico Wi-Fi product.
** THIS SOFTWARE AND ANY ACCOMPANYING DOCUMENTATION IS PROVIDED "AS IS".
** LANTRONIX SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
** TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS
** FOR A PARTICULAR PURPOSE.
** LANTRONIX HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
** ENHANCEMENTS, OR MODIFICATIONS TO THIS SOFTWARE.
** IN NO EVENT SHALL LANTRONIX BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
** SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
** ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
** LANTRONIX HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*****************************************************************************/
/*                           Documentation                                   */
/*****************************************************************************/

/*!
** \addtogroup example
** @{
*/

/*!
** \defgroup spi_log spi_log
** @{
**
** The \b spi_log module implements implements a rudimentary "SPI Protocol".
** When this protocol is chosen by a SPI, it logs whatever it receives on the
** SPI.
**
** Build it from project "spiLogDemo".
**
** To run it you will need to select protocol "Log" under SPI Configuration.
**
** Also, you will need to enable the SPI CPs: Under CPM Roles Configuration,
** enable the SPI group of CPs.
** HINT: If using the evaluation board, you may place a jumper between JP5
** pins CP3 and CP4 to effect a loopback of your SPI data.
** Note that the SPI group of CPs is ganged, so when you enable one, you
** enable them all.
** Also note that all the other CPM Roles referring to any of the SPI CPs must
** be disabled.
*/

/*****************************************************************************/
/*                             Includes                                      */
/*****************************************************************************/
#include <string.h>

#include "ltrx_compile_defines.h" /* Delivered with SDK. */
#include "main_module_libs.h" /* Delivered with SDK. */
#include "ltrx_cpm.h"
#include "dotstar_strip_module_defs.h" /* Automatically generated by make. */
#include "user_data_module_definitions.h" /* Delivered with SDK. */


/*****************************************************************************/
/*                              Defines                                      */
/*****************************************************************************/

#define EXPECTED_MAIN_INTERFACE_VERSION 1

#define MAX_TRANSFER_LENGTH 4

#define LED_NUMBER 30

/*****************************************************************************/
/*                             Structs                                       */
/*****************************************************************************/

struct thread_info
{
    uint32_t zeroBasedIndex;
    bool isRunning;
    struct ltrx_ip_socket *socket;
    struct ltrx_ip_socket *sock2;
    struct ltrx_trigger eventTrigger;
    struct ltrx_trigger dataTrigger;
};

/*****************************************************************************/
/*                            Prototypes                                     */
/*****************************************************************************/

bool StartSpiDotStar(uint16_t zeroBasedIndex);
void StopSpiDotStar(uint16_t zeroBasedIndex);

/*****************************************************************************/
/*                         Local Constants                                   */
/*****************************************************************************/

static const struct ltrx_spi_protocol s_spiProtocol = {
	.protocolName  = "DotStarLED",
	.startProtocol = StartSpiDotStar,
	.stopProtocol  = StopSpiDotStar
};

static const uint8_t led_start[4] = "\0\0\0\0";
static const uint8_t led_end[4] = {0xFF, 0xFF, 0xFF, 0xFF};

/*****************************************************************************/
/*                         Local Variables                                   */
/*****************************************************************************/

static struct thread_info *s_threadInfo[MAX_SPI_EXTERNAL];
static struct ltrx_thread *s_threadForSpi[MAX_SPI_EXTERNAL];

/*****************************************************************************/
/*                              Globals                                      */
/*****************************************************************************/

const struct main_external_functions *g_mainExternalFunctionEntry_pointer = 0;

/*****************************************************************************/
/*                               Code                                        */
/*****************************************************************************/

void dotstar_strip_module_initialization(
    const struct main_external_functions *mef
)
{
    if(
        mef &&
        mef->current_interface_version >= EXPECTED_MAIN_INTERFACE_VERSION &&
        mef->backward_compatible_down_to_version <= EXPECTED_MAIN_INTERFACE_VERSION
    )
    {
        g_mainExternalFunctionEntry_pointer = mef;
        ltrx_module_register(&g_dotstar_stripModuleInfo);
        ltrx_spi_register_protocol(&s_spiProtocol);
    }
}

static bool getXmlValue(const struct xml_emit_value_specification *xevs,char *buffer,size_t size) {
    struct output_stream_to_buffer osb;
    ltrx_output_stream_init_to_buffer(
		&osb, buffer, size, OUTPUT_STREAM_TO_BUFFER_MODE__ZERO_TERMINATE
	);
    return(ltrx_xml_emit_value(xevs, &osb.outStream));
}

static void sendSpi(uint8_t *txBuffer, uint32_t received) {
  uint8_t rxBuffer[received];
  struct ltrx_spi_descriptor lsd = {
    .cmd_bytes = 4,
    .cmd_buf = led_start,
    .data_bytes = received,
    .miso_buf = rxBuffer,
    .mosi_buf = txBuffer
  };
  ltrx_spi_transfer(0, &lsd);
  lsd.cmd_buf = led_end;
  lsd.data_bytes = 0;
  ltrx_spi_transfer(0, &lsd);
}

static void shiftLeft(uint8_t *buf,size_t shift, size_t size) {
  uint8_t temp[shift];
  memcpy(temp,buf,shift);
  memcpy(buf,buf+shift,size-shift);
  memcpy(buf+size-shift,temp,shift);
}

static void shiftRight(uint8_t *buf, size_t shift, size_t size) {
  uint8_t temp[size-shift];
  memcpy(temp,buf,size-shift);
  memcpy(buf,buf+size-shift,shift);
  memcpy(buf+shift,temp,size-shift);
}

static void dataReader(void *opaque) {
  struct thread_info *ti = opaque;
  uint32_t received;
  uint8_t *txBuffer;
  size_t size, part;

  while(ti->isRunning) {
    LTRX_TRIGGER_WAIT(&ti->dataTrigger,TIME_WAIT_FOREVER);
    ltrx_trigger_clear(&ti->dataTrigger);
    if(ltrx_ip_socket_has_data(ti->socket,0) || ltrx_ip_socket_has_data(ti->sock2,0) ) {
      if(ltrx_ip_socket_has_data(ti->socket,0)) {
        received = ltrx_ip_socket_receive(ti->socket, &txBuffer, 2048);
      } else {
        received = ltrx_ip_socket_receive(ti->sock2, &txBuffer, 2048);
      }
      switch(txBuffer[0]) {
        case 0x00:  // Send all the data after the initial 0
          sendSpi(txBuffer+1,received-1);
          break;
        case 0x01:  // Make all same pattern
          size = txBuffer[1]*4;
          part = received-2;
          if (part > 3) {
            uint8_t buf[size];
            for(uint32_t i=0;i<size;i+=part) {
              memcpy(buf+i,txBuffer+2,MINIMUM(part,size-i));
            }
            sendSpi(buf,size);
          }
          break;
        case 0x02:
        /* Rotating pattern
          First byte: 02
          Second byte: number of leds
          Third byte: increment of 20ms for rotate
          After that: pattern */
          {
          size = txBuffer[1]*4;
          part = received-3;
          uint8_t buf[size];
          for(uint32_t i=0;i<size;i+=part) {
            memcpy(buf+i,txBuffer+3,MINIMUM(part,size-i));
          }
          while(!LTRX_TRIGGER_WAIT(&ti->dataTrigger,txBuffer[2]*20)) {
            sendSpi(buf,size);
            shiftRight(buf,4,size);
          }
        }
          break;
        case 0x03:
        {
          size = txBuffer[1]*4;
          part = received-3;
          uint8_t buf[size];
          memset(buf,0xE0,size);
          memcpy(buf,txBuffer+3,part);
          size_t pos=0;
          bool right = true;
          while(!LTRX_TRIGGER_WAIT(&ti->dataTrigger,txBuffer[2]*20)) {
            sendSpi(buf,size);
            if(right) {
              shiftRight(buf,part,size);
              pos+=part;
              if(pos >= (size)-part) {
                right = false;
              }
            } else {
              shiftLeft(buf,part,size);
              pos-=part;
              if(pos < 1) {
                right = true;
              }
            }
          }
        }
          break;
      }
    }
  }
}

static uint32_t getPortFromConfig(void) {
  char buffer[6];
  char *ptr;
  static const struct xml_emit_value_specification s_xevs = {
    .type = XML_EMIT_VALUE_TYPE__CONFIGURATION,
    .groupName = "Custom",
    .optGroupInstance = "Network",
    .itemName = "Item",
    .optItemInstance = "Port",
    .optValueName = "Value"
  };
  if(getXmlValue(&s_xevs, buffer, sizeof(buffer))) {
    TLOG(TLOG_SEVERITY_LEVEL__INFORMATIONAL, "Port: %s", buffer);
    uint32_t port = (uint32_t)strtol(buffer,&ptr,10);
    if(port > 0 && port < 64000) {
      return port;
    }
  }
  return 0;
}

static void spiThread(void *opaque)
{
    uint16_t zeroBasedIndex = (uint32_t)opaque;
    bool loggedStartMessage = false;
    struct thread_info ti =
    {
        .zeroBasedIndex = zeroBasedIndex,
        .isRunning = true,
        .socket = NULL
    };
    if(! ltrx_trigger_create(&ti.eventTrigger, s_spiProtocol.protocolName))
        return;
    if(! ltrx_trigger_create(&ti.dataTrigger, "data"))
      return;
    s_threadInfo[zeroBasedIndex] = &ti;
    while(
        ti.isRunning &&
        ! ltrx_spi_open(zeroBasedIndex, 1000)
    );
    if(ti.isRunning)
    {
        TLOG(
            TLOG_SEVERITY_LEVEL__INFORMATIONAL,
            "%s started on SPI %u",
            s_spiProtocol.protocolName,
            zeroBasedIndex + 1
        );
        loggedStartMessage = true;
    }
    if(ti.isRunning)
    {
        ltrx_trigger_clear(&ti.eventTrigger);
        struct ltrx_udp_socket_options luso = {
          .optLocalPort = getPortFromConfig(),
          .optReceiveEventTrigger = &ti.dataTrigger,
          .zeroBasedInterface = NETS_SOFTAP_START
        };
        if(luso.optLocalPort != 0) {
          ltrx_thread_create("Data processor",dataReader,(void *)&ti,2000);
          while(ti.socket == NULL) {
            ti.socket = ltrx_udp_socket_open_with_options(&luso);
            ltrx_thread_sleep(100);
          }
          luso.zeroBasedInterface = NETS_WLAN_START;
          while(ti.sock2 == NULL) {
            ti.sock2 = ltrx_udp_socket_open_with_options(&luso);
            ltrx_thread_sleep(1000);
          }
          LTRX_TRIGGER_WAIT(&ti.eventTrigger, TIME_WAIT_FOREVER);
          ltrx_trigger_signal(&ti.dataTrigger);
          ltrx_thread_yield();
          ltrx_udp_socket_close(ti.socket);
          ltrx_udp_socket_close(ti.sock2);
          ti.socket = NULL;
          ti.sock2 = NULL;
      }
    }
    if(loggedStartMessage)
    {
        TLOG(
            TLOG_SEVERITY_LEVEL__INFORMATIONAL,
            "%s stopped on SPI %u",
            s_spiProtocol.protocolName,
            zeroBasedIndex + 1
        );
    }
    ltrx_spi_close(zeroBasedIndex);
    s_threadInfo[zeroBasedIndex] = NULL;
    s_threadForSpi[zeroBasedIndex] = 0;
}

bool StartSpiDotStar(uint16_t zeroBasedIndex)
{
    if(s_threadInfo[zeroBasedIndex] || s_threadForSpi[zeroBasedIndex])
    {
        TLOG(
            TLOG_SEVERITY_LEVEL__ERROR,
            "%s thread already running for SPI %u",
            s_spiProtocol.protocolName,
            zeroBasedIndex + 1
        );
        return false;
    }
    s_threadForSpi[zeroBasedIndex] = ltrx_thread_create(
        s_spiProtocol.protocolName,
        spiThread,
        (void *)(uint32_t)zeroBasedIndex,
        3000
    );
    if(! s_threadForSpi[zeroBasedIndex])
    {
        TLOG(
            TLOG_SEVERITY_LEVEL__ERROR,
            "Failed to create %s thread for SPI %u",
            s_spiProtocol.protocolName,
            zeroBasedIndex + 1
        );
        return false;
    }
    return true;
}

void StopSpiDotStar(uint16_t zeroBasedIndex)
{
    bool wasRunning = false;
    struct thread_info *ti;
    ltrx_block_preemption();
    ti = s_threadInfo[zeroBasedIndex];
    if(ti && ti->isRunning)
    {
        wasRunning = true;
        ti->isRunning = false;
        ltrx_trigger_signal(&ti->eventTrigger);
    }
    ltrx_unblock_preemption();
    if(wasRunning)
    {
        struct ltrx_thread *lt;
        while(
            (lt = s_threadForSpi[zeroBasedIndex]) != NULL &&
            lt != ltrx_threadid()
        )
        {
            ltrx_thread_sleep(100);
        }
    }
}

/*!
** @}
*/

/*!
** @}
*/
